---
title: JVM内存结构(1)
tags: [JVM]
copyright: true
date: 2016-04-23 21:20:43
updated: 2016-04-23 22:29:00
categories: JVM
---

### JVM内存结构（运行时数据区）
JVM内存结构指得是：运行时数据区（Runtime Data Area），由 ***方法区(Method Area) ***、***堆(Heap) ***、***Java栈(Java Stack) ***、***本地方法栈(Native Method Stack)***、***程序计数器(Program Counter Register)***。
![](http://p5vswdxl9.bkt.clouddn.com/JVMRuntime)

<!-- more -->

--------------------

#### 一、方法区(Method Area)  
1. **作用**： 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。此区域内存回收目标主要针对常量池回收和对类型的卸载回收。 
2. **特点**：线程共享 。
3. **永久代的疑问(PerGen)**：该内存区域一般被称为"**永久代(Permanent Generation)** "，二者并不等价，设计之初就把GC分代收集扩展至方法区，或者说使用永久代实现方法区而已。
4. **运行时常量池**：方法区的一部分，存放***编译期***生成的**各种字面量**("zdy","123"等)和 **符号引用** 。编译器和运行期的intern()都可以将常量放入池中。受方法区限制，常量池无法申请到内存时会抛出OutOfMemoryError异常。运行时常量池具有动态性，并非只有Class文件中的内容才能进入运行时常量池，***运行期间***也能将新的常量放入池中。如String.intern（）方法。
5. **方法区储存类的信息**： 
    1. `Classloader引用`；
    2. `运行时常量池`：数值型常量、字段引用、方法引用、属   性；  
    3. `字段数据`：针对每个字段的信息、字段名、类型、修饰符、属性；
    4. `方法数据`：每个方法、方法名、返回值类型、参数类型、修饰符、属性；
    5. `方法代码`：每个方法、字节码、操作数栈大小、局部变量大小、局部变量表、异常表、每个异常处理器、开始点、结束点、异常处理代码的程序计数器偏移量、被捕获异常类对应的常量池下标；
         
* *** 字面量(literal) ***：由字母，数字等构成的字符串或者数值，用于表达源代码中一个固定值的表示法(notation)。几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；而有很多也对布尔类型和字符类型的值也支持字面量表示；还有一些甚至对枚举类型的元素以及像数组、记录和对象等复合类型的值也支持字面量表示法。
* *** 符号引用 ***：简单地说就是，符号引用存在class文件中的常量池，包括类和接口的全限定名、字段的名称和描述符以及方法的名称和描述符。jvm加载class的时候就可以凭着这三者进行动态连接，得到具体的内存地址。占用的数据结构在常量池项目类型有，例如类或接口的符号引用结构为u1的tag和u2的name_index。
--------------------
#### 二、堆(Heap)
1. ** 作用 **：被所有线程运行时共享的内存区域，JVM启动之后，存放对象实例和数组，内部会划出多个线程私有的分配缓冲区(Thread Location Allocation Buffer ,__TLAB__)。该存储区域物理上可以是不连续空间，但是逻辑上一定要连续。
2. ** 特点 **：是GC管理的主要区域，由于GC（垃圾收集器）是采用分代收集算法,根据对象存活率，堆还可以分为**新生代**、**老年代**、**永久代**。
3. ** 分类 **：
    > _**新生代(Young Generation)**_ ：方法中去new一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象。 每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理Eden和刚才用过的Survivor空间。*** HotSpot虚拟机默认Eden和Survivor的大小比例是8:1 ***，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。 98%的对象可回收只是一般场景下的数据，没办法保证每次回收都只有不多于10%的对象存活，当Survivor不够用时，需要依赖于老年代进行分配担保，所以*** 大对象 ***直接进入老年代。同时长期存活的对象进入老年代（虚拟机给每个对象定义一个年龄计数器）。    
`年轻代内存又被分成三部分`：  
    1. `Eden空间`：对象优先分配在Eden区，若Eden区无足够的空间，虚拟机执行一次Minor GC。对象被创建时首先放到这个区域，进行垃圾回收后，不能被回收的对象被放到空的Survivor区域。
    2. `Survivor Space幸存者区`：用于保存在Eden Space内存区域中经过垃圾回收后没有被回收的对象。Survivor有两类，分别为***To Suvivor *** 和 ***From Suvivor***两个区域，这两个区域空间大小是一样的执行：
          &emsp;&emsp;a.`From Survivor空间`：
          &emsp;&emsp;b.`To Survivor空间` ：      
    3. `执行回收的内存运行`： 执行垃圾回收时Eden区域不能被回收的对象被放入到空的Suvivor(也就是**To Survivor**，同时Eden区域的内存会在垃圾回收的过程中全部释放)，另一个Survivor(即From Survivor)里不能被回收的对象也会被放入到Survivor(即To Survivor)，然后To Survivor和 From Survivor的标记会互换，始终保证一个Survivor是空的。 
      
 > _**老年代(Old Generation)**_ ：** 老年代空间大小&emsp;=&emsp;堆空间大小&emsp;--&emsp;年轻代大空间大小 **   
4. ** 年轻代的垃圾回收 **：***Eden Space(伊甸园) ***和***Suvivor Space ***都属于新生代，新生代中执行垃圾回收被称为Minor GC(由于是对新生代进行垃圾回收，所以被称为Young GC)，每次Young GC 后留下来的对象age +1。
    > _** Eden:From:TO =8:1:1**_    
    由于新生代中90%的对象都是"朝生夕死"，采用复制算法是比较合理的，首先只移动了存活下来的对象(比较少数),其次内存在移动到To区域后是有顺序的，不存在内存碎片。值得一提的是，假如在一次Minor GC时,`Eden中存活的对象`+`From中存活的对象`>`To的剩余空间`，则会通过担保机制将对象直接转移到Old Gen ,如果Old Gen的内存空间也不够，则进行一次Full GC .当*** 对象的年龄到达15岁时会转移到Old Gen(可通过参数配置，一般不建议更改) ***
    
5. ** 使用方式 **：Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。*** 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 ***
6. `对象分配规则`：  
    `1.对象优先分配在Eden区`：若Eden区没有足够的空间时，虚拟机执行一次Minor GC；
    `2.大对象(大对象是指需要大量连续内存空间的对象)直接进入老年代`：这样做目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝(新生代采用 ***复制算法 *** 收集内存)； 
    `3.长期存活的对象进入老年代`：虚拟机为每个对象定义一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象年龄加 1，直到达到阀值，对象进入老年区；
    `4.动态判断对象的年龄`：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代；
    `5.空间分配担保`：每次每次进行Minor GC时，JVM会计算Survivor区移至**老年区的对象**的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC，如果false则进行Full GC；    
                   
-------



